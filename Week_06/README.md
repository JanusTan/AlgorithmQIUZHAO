## 学习笔记  
### 堆排序：  
堆的性质。总是以O(1)的时间复杂度查询最大值或最小值。插入和删除操作的时间复杂度是O(logn), 一般用优先队列去维护一个堆  
排序的时间复杂度O(nlogn), 数组元素依次建立小顶堆，依次取堆顶元素并删除     
### 字符串    
python里的定义的string变量（a = "1,2,3"）是不可变的immutable，即向a添加一个元素时，会重新创建了一个string  
#### 字母异位词  
所有出现的单词个数都相同的单词  
#### 回文字符串  
字符串里面找正读何反读字母顺序都一样的单词，如level  
#### 公共子序列和公共子串    
两字符串的公共子序列不要求连续。即apple,aopp的公共子序列是app。  
而公共子串是要求连续的，上两字符串的的公共子串是a, pp  
#### 字符串匹配    
在一个长的的字符串里面找有没有出现过某单词    
##### Rabin-Karp字符串匹配算法  
在原来暴力匹配的基础上，利用哈希函数的值来进行加速匹配  
##### KMP字符串匹配算法  
根据前面已经匹配成功的部分子序列，不要搜索位置停留在比较过的位置，而是大步向后移，加快匹配速度  
### 哈希表、布隆过滤器bloom filter、LRU Cache     
#### 哈希表  
存储重复的重复的元素采用的是在对应的相同的哈希函数index下，用链表的形式把两个重复的元素串在一起  
#### 布隆过滤器bloom filter：  
利用二进制存储元素信息，快速查询某个元素是否在表里，只能输出可能在和一定不在两种状态，可能在还需要通过数据库的进一步确认  
#### LRU Cache： 
least recently used缓存。最近最少使用缓存机制。使用哈希表和双向链表实现。获取数据 get(key) - 如果关键字 (key) 存在于缓存中，
则获取关键字的值（总是正数），否则返回 -1。  写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，
则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。  

### 爬楼梯变形  
能走1或2或3个台阶每次，则dp[i] = dp[i-3] + dp[i-2] + dp[i-1]  
走x1,x2,x3个台阶，在原本循环里面嵌套一个循环j算dp[i] += dp[i-x[j]]
相邻步数要求不一样：再二的基础上，再嵌套一个循环k（此时三层循环）dp方程变成二维dp[i][k]，第一维表示当前台阶数，第二维表示当前是x1,x2,x3哪个步伐上来的
dp[i][x[j]] += dp[i - x[j]][x[k]]加个if筛掉x[j]   