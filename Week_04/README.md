## 学习笔记  
面试题的本质：找重复子问题（找重复性问题），拒绝人肉递归，数学归纳法的思想  
### DP(dynamic programming)动态规划   
通过将复杂的问题分解成简单的子问题，递推的思想    
求最优解/最大值/最少的一个方式  
分治+最优子结构，每一轮递归都保留当前最优的状态。动态规划和递归或者分治没有根本上的区别（关键看有无最优子结构，DP中途可以淘汰次优解）  
#### DP关键点  
opt是optimal缩写  
1. 最优子结构 opt[n] = best_of(opt[n-1], opt[n-2],...); # 有时候是简单的累加，有时候是取最大值/最小值  
2. 存储中间状态：opt[i] # 一般的DP问题，这一步最重要，用一个数组存储子最优中间值  
3. 递找DP方推公式（又叫状态转移方程、DP方程）# 难的DP题就是程  
Fib: opt[i] = opt[n-1] + opt[n-2] # 斐波那契数列求和的，就是一维DP  
二维路径：opt[i,j] = opt[i+1][j] + opt[i][j+1](且判断a[i][j]是否空地) # 二维DP，LeetCode最小路径和  
##### 爬楼梯问题的变形机器DP方程  
1. 原题-每次只能走1或2个阶梯  
2. 每次可以走1或2或3个阶梯  
3. 要求相邻两步的步伐不能相同  

### python编程  
#### 初始化一个一维矩阵 1xk  
dp = [[0]*k]  # [[0, 0, 0]] 1x3 # 注意此时dp[1]是读不到第二个0的，要用 [0 for _ in range(3)] 输出[0, 0, 0]才能读dp[1]
#### 初始化一个二维矩阵 nxk  
dp = [[0]*k for i in range(n)] # [[0, 0], [0, 0], [0, 0]]是一个3x2  
#### 初始化一个三维矩阵 m x n x k  
dp = [[[0]*k for i in range(n)] for i in range(m)]  
[[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]], [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]] # 2x3x4  

### 股票系列的题  
6道，分别是最大购买次数k有三种情况：k = +inf/1/2/integer。冷静期，手续费  
状态分析：dp[i][k][0/1]表示第i天在允许最大的购买次数k下没有持股/持股的最大利润。最终返回的结果应该是dp[i][k][0]  
DP方程： dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + price[i])  
        dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - price[i])  
k =  
+inf: k可以忽略，因为k-1也是正无穷，可以用两个变量存储完式子里的dp状态  
/1：k可以忽略，dp[i-1][0][0] = 0， 可以用两个变量存储完式子里的dp状态  
/2：分别罗列k=2, k=1时的DP方程, 可以用四个变量存储完式子里的dp状态  
/integer：倒序遍历k，初始化一个三维矩阵  