## 学习笔记  
  
### python编程
#### 所有冒号的右边的数字都是取不到的，  
a[0:2]只表示a[0],a[1].  
若a有n个元素，a[:-1]表示a[0],a[1],..,a[n-2]
range(0,100)表示0,1,2,..,99  
range(100,-1,-1)表示100,99,98,...,0
#### python与二进制  
python二进制格式0b00001,要0b开头，bin(十进制)可快速转换,int(二进制)转换为十进制
#### python输出a~z  
import string  
string.ascii_lowercase, string.ascii_uppercase  
#### join函数
Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。  如  
str = "-";  
seq = ("a", "b", "c"); # 字符串序列  
print str.join( seq );  # 输出a-b-c  
 
### 字典树trie(单词查找树) 
有小伙伴面试字节的时候要求写字典树 
经常用于搜索引擎系统用于文本词频统计  
最大限度减少所谓的字符串比较，查询效率比哈希表高，因为查询的速度是单词的长度，而字典里查二分也要很久  
节点本身不存完整的单词，节点上还存着这个单词的频次
  
  
### 并查集   
某两元素在不在一个集合里面 
朋友圈（经典题目） 
岛屿数量  
  
### 高级搜索
初级搜索：DFS、BFS  
高级搜索：剪枝、A*  
#### 剪枝  
在DFS搜索过程中减掉一些不符合要求的递归子树，如括号生成题目中的筛选  
解数独，华为考了  
#### 双向BFS  
想修一条铁路，经过一个山洞，可以在山洞的两遍同时开始修，相遇时问题就解决了   
单词接龙/单词接龙II、最小基因变化都可以用BFS、双向BFS解决  
#### A星  
带有优先级的高级搜索，用到collections库里的heapq，利用曼哈距离（坐标的绝对值的和）和估价函数决定智能搜索的方向  
   
### 平衡二叉树（掌握概念和插入的操作即可，不考代码）  
二叉搜索树在不断地插入删除操作后，容易变成单链表，而查询的时间复杂度和树的深度相关（查询的效率会从O(logn)退化为O(n)），因此出现了平衡二叉树    
#### AVL  
平衡因子：所有左右子树高度差始终为1,0，或-1  
插入操作： 左旋（右右子树）、右旋（左左子树），左右旋（左右子树）、右左旋（右左子树）  
#### 近似平衡二叉树   
红黑树：左右树高度差是小于两倍。约束降低，插入和删除更快，红黑树更适合增删多的场景  
  
### 位运算   
十进制转换到二进制：一直除2取余数，直到商为0（短除法），然后余数倒序排就是对应的二进制数了  
左移<<, 右移>>  
按位运算：或|(有点像加运算但是1或1是1)、与&(有点像乘法)、取反~、异或（相同取0，不同取1）    
n&(n-1)打掉n的最低位的1（如判断一个数是否是2的n次方）  
